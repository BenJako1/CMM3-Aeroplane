#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''

CMM3 Group 7
Benjamin, Rodrigo, Maurice, Nick, Jack, Stamatis
October-November 2023  

'''

# Import libraries & modules
import numpy as np
import matplotlib.pyplot as plt
from scipy import integrate, optimize
import forms
import constants as c

#------------------------------------------------------------------------------
# User parameters (to be replaced with UI)

velocity_0 = 109 # Velocity in m/s
gamma_0 = 0 # Path angle in radians

pitchTime = 10 # Time in seconds after simulationstart at which the values are changed
max_altitude = 2000

climbVelocity = velocity_0
climbGamma = np.deg2rad(2)
climbTimeGuess = 200
climbStep = 0.5

elevatorChange = 10 # in percent
thrustChange = 0 # in percent

initialAltitude = 1000 # Altitude at t=0
maxAltitude = 2000

#------------------------------------------------------------------------------
# Class for handling the trim condition

class Trim:
    def __init__(self, trimVelocity, trimGamma):
        self.velocity = trimVelocity
        self.gamma = trimGamma
        
        # Solve for alpha
        initial_guess = 0.01  # Provide an initial guess
        self.alpha = optimize.newton(self.alpha_trim_func, initial_guess)
        
        # Solve for delta
        self.delta = -(c.CM0 + c.CMa * self.alpha) / c.CMde
    
        # Calculating other variables to output
        self.theta = self.alpha + trimGamma
        self.ub = trimVelocity * np.cos(self.alpha)
        self.wb = trimVelocity * np.sin(self.alpha)
    
        # Calculating thrust
        self.thrust = forms.Engine_Thrust(self.alpha, self.delta, self.theta, trimVelocity)
        
    def alpha_trim_func(self, alpha):
        self.delta = -(c.CM0 + c.CMa * alpha) / c.CMde

        return (-forms.Lift(alpha, self.delta, self.velocity) * np.cos(alpha) - forms.Drag(alpha, self.delta, self.velocity) * np.sin(alpha) + c.mass * c.gravity * np.cos(alpha + self.gamma))

#------------------------------------------------------------------------------
# Backend class to handle data and store diff. equations (should be a clearer name)

class Visualise():
    
    # Simulations visualisation
    def Display(self, Data,initialAltitude = 0):
        # Split data into components
        self.t = Data.t
        self.q = Data.y[0]
        self.theta = Data.y[1]
        self.ub = Data.y[2]
        self.wb = Data.y[3]
        self.xe = Data.y[4]
        self.ze = Data.y[5]
        
        # Calculate altitude because ze is reversed for some reason
        self.altitude = self.ze * -1
        #self.altitude += initialAltitude

        # Create plot
        fig,ax = plt.subplots(3, 2)
        
        # Format axes
        ax[0,0].set_ylabel("$u_{B}$", rotation='horizontal')
        ax[0,0].set_xlabel("t")
        ax[0,1].set_ylabel("$w_{B}$", rotation='horizontal')
        ax[0,1].set_xlabel("t")
        ax[1,0].set_ylabel("${\Theta}$", rotation='horizontal')
        ax[1,0].set_xlabel("t")
        ax[1,1].set_ylabel("q", rotation='horizontal')
        ax[1,1].set_xlabel("t")
        ax[2,0].set_ylabel("$x_{e}$", rotation='horizontal')
        ax[2,0].set_xlabel("t")
        ax[2,1].set_ylabel("Altitude h")
        ax[2,1].set_xlabel("t")
        
        # Plot data
        ax[0,0].plot(self.t, self.ub)
        ax[0,1].plot(self.t, self.wb)
        ax[1,0].plot(self.t, self.theta)
        ax[1,1].plot(self.t, self.q)
        ax[2,0].plot(self.t, self.xe)
        ax[2,1].plot(self.t, self.altitude)
        
        # Show
        plt.show()
    
    def DisplayB1(self, V_values, gama_values, T_values, δE_values):
       # Create a single figure with all the required subplots
       plt.figure(figsize=(14, 10))

       # Plot Thrust vs Velocity
       plt.subplot(2, 2, 1)
       for j, gama in enumerate(gama_values):
           plt.plot(V_values, T_values[:, j], label=f'gama = {np.rad2deg(gama)}°')
       plt.xlabel('Velocity (V)')
       plt.ylabel('Thrust (T)')
       plt.title('Thrust vs. Velocity')
       plt.legend()

       # Plot Elevator Angle vs Velocity
       plt.subplot(2, 2, 2)
       for j, gama in enumerate(gama_values):
           plt.plot(V_values, δE_values[:, j], label=f'gama = {np.rad2deg(gama)}°')
       plt.xlabel('Velocity (V)')
       plt.ylabel('Elevator Angle (δE) (degrees)')
       plt.title('Elevator Angle vs. Velocity')
       plt.legend()

       # Plot Thrust vs Gama
       plt.subplot(2, 2, 3)
       for i, V in enumerate(V_values):
           plt.plot(gama_values, T_values[i, :], label=f'V = {V} m/s')
       plt.xlabel('Flight Path Angle (gama)')
       plt.ylabel('Thrust (T)')
       plt.title('Thrust vs Flight Path Angle')
       plt.legend()

       # Plot Elevator Angle vs Flight Path Angle
       plt.subplot(2, 2, 4)
       for i, V in enumerate(V_values):
           plt.plot(np.rad2deg(gama_values), δE_values[i, :], label=f'V = {V} m/s')
       plt.xlabel('Flight Path Angle (gama) (degrees)')
       plt.ylabel('Elevator Angle (δE) (degrees)')
       plt.title('Elevator Angle vs Flight Path Angle')
       plt.legend()

       # Adjust the layout for better appearance
       plt.tight_layout()

       # Display the plots
       plt.show()
        
#------------------------------------------------------------------------------
# Part B1 - Class to handle the trim condition and visualization
class B1(Visualise):
    def __init__(self, V_min, V_max, gama_min, gama_max, V_step, gama_step):
        # Define the ranges for V and gama
        self.V_min = V_min
        self.V_max = V_max
        self.gama_min = gama_min
        self.gama_max = gama_max

        # Define step sizes for V and gama
        self.V_step = V_step
        self.gama_step = gama_step

        # Create arrays to store results
        self.V_values = np.arange(self.V_min, self.V_max, self.V_step)
        self.gama_values = np.arange(self.gama_min, self.gama_max, self.gama_step)

        # Create arrays to store T and δE
        self.T_values = np.empty((len(self.V_values), len(self.gama_values)))
        self.δE_values = np.empty((len(self.V_values), len(self.gama_values)))

        for i, V in enumerate(self.V_values):
            for j, gama in enumerate(self.gama_values):
                # Create a new Trim instance with the current V and gama
                trim_condition = Trim(V, gama)

                # Store T and δE values from the trim condition
                self.T_values[i, j] = trim_condition.thrust
                self.δE_values[i, j] = np.rad2deg(trim_condition.delta)

#------------------------------------------------------------------------------
# Simulation calculation and control class

class Simulation(Visualise):
    def __init__(self, trimVelocity, trimGamma, t_end):
        
        # Find trim conditions
        trimParams = Trim(trimVelocity, trimGamma)
        self.Trim = trimParams
        
        trimParams2 = Trim(climbVelocity, climbGamma)
        self.Trim2 = trimParams2
        
        self.climbTime = climbTimeGuess
        
        finalAltitude = initialAltitude
        
        while finalAltitude < maxAltitude:
            y = integrate.solve_ivp(self.SimControl, [0,t_end], [0,trimParams.theta, trimParams.ub, trimParams.wb, 0, -initialAltitude], t_eval=np.linspace(0,t_end,t_end*50))
            finalAltitude = -y.y[5][len(y.y[5])-1]
            
            self.climbTime += climbStep
            
        # Send data to "Display" function to be plotted
        self.Display(y, initialAltitude)
        print(f"Climb Duration: {self.climbTime}s")
    
    # Function to change delta and thrust during IVP calculations
    def SimControl(self, t, y):
        if t > pitchTime and t < pitchTime + self.climbTime:
            delta = self.Trim2.delta
            thrust = self.Trim2.thrust
        else:
            delta = self.Trim.delta
            thrust = self.Trim.thrust

        return forms.Equations(t, y, delta, thrust)

# Running the simulation
Simulation(velocity_0, gamma_0, 500)
